# coder:也
# 开发时间:2022/11/25 16:10

'''
函数参数是可选参数，不需要声明类型，也不需要指定函数返回值类型
多个参数用逗号隔开
即使该函数不需要接收任何参数，也必须保留一对空的圆括号
括号后面的冒号必不可少
函数体相对于def关键字必须保持一定的空格缩进
Python允许嵌套定义函数

在Python中，定义函数时也不需要声明函数的返回值类型，而是使用return语句结束函数执行的同时返回任意类型的值，函数返回值类型与return语句返回表达式的类型一致。
不论return语句出现在函数的什么位置，一旦得到执行将直接结束函数的执行。
如果函数没有return语句、有return语句但是没有执行到或者执行了不返回任何值的return语句，解释器都会认为该函数以return None结束，即返回空值
'''

# 函数调用是将实参的引用传递给形参，这一过程称为参数传递
'''
在调用带有默认值参数的函数时，可以不用为设置了默认值的形参进行传值，此时函数将会直接使用函数定义时设置的默认值，当然也可以通过显式赋值来替换其默认值。在调用函数时是否为默认值参数传递实参是可选的。
需要注意的是，在定义带有默认值参数的函数时，任何一个默认值参数右边都不能再出现没有默认值的普通位置参数，否则会提示语法错误。
'''

# 可以使用“函数名.__defaults__”随时查看函数所有默认值参数的当前值，其返回值为一个元组，其中的元素依次表示每个默认值参数的当前值


def say(message, time=1):
    print((message+' ')*time)


print(say.__defaults__)

'''
多次调用函数并且不为默认值参数传递值时，默认值参数只在定义时进行一次解释和初始化，对于列表、字典这样可变类型的默认值参数，这一点可能会导致很严重的逻辑错误。例如：
>>> def demo(newitem, old_list=[]):
        old_list.append(newitem)
        return old_list

>>> print(demo('5', [1, 2, 3, 4]))
[1, 2, 3, 4, '5']
>>> print(demo('aaa', ['a', 'b']))
['a', 'b', 'aaa']
>>> print(demo('a'))
['a']
>>> print(demo('b'))                 #注意这里的输出结果
['a', 'b']
'''
'''
函数的默认值参数是在函数定义时确定值的，所以只会被初始化一次。

>>> i = 3
>>> def f(n=i):                 #参数n的值仅取决于i的当前值
        print(n)
>>> f()
3
>>> i = 5                       #函数定义后修改i的值不影响参数n的默认值
>>> f()
3
>>> i = 7
>>> f()
3
>>> def f(n=i):                 #重新定义函数
        print(n)
>>> f()
7
'''
'''
关键参数主要指调用函数时的参数传递方式，与函数定义无关。通过关键参数可以按参数名字传递值，明确指定哪个值传递给哪个参数，实参顺序可以和形参顺序不一致，但不影响参数值的传递结果，避免了用户需要牢记参数位置和顺序的麻烦，使得函数的调用和参数传递更加灵活方便。

>>> def demo(a, b, c=5):
    print(a, b, c)
>>> demo(3, 7)               #位置实参
3 7 5
>>> demo(a=7, b=3, c=6)      #关键字实参
7 3 6
>>> demo(c=8, a=9, b=0)
9 0 8
'''
'''
可变位置参数*parameter的用法—var-positional parameter

>>> def demo(*p):
        print(p)

>>> demo(1,2,3)
(1, 2, 3)
>>> demo(1,2)
(1, 2)
>>> demo(1,2,3,4,5,6,7)
(1, 2, 3, 4, 5, 6, 7)

可变关键字参数 **parameter的用法—var-keyword parameter

def demo(**p):
    for item in p.items():
        print(item)

>>> demo(x=1, y=2, z=3)
('x', 1)
('y', 2)
('z', 3)


如果函数实参是字典，可以在前面加两个星号进行解包，等价于关键参数。
>>> def demo(a, b, c):
        print(a+b+c)

>>> dic = {'a':1, 'b':2, 'c':3}
>>> demo(**dic)
6
>>> demo(a=1, b=2, c=3)
6
>>> demo(*dic.values())
6

注意：调用函数时对实参序列使用一个星号*进行解包后的实参将会被当做普通位置参数对待，并且会在关键参数和使用两个星号**进行序列解包的参数之前进行处理。
>>> def demo(a, b, c):                #定义函数
        print(a, b, c)	
>>> demo(*(1, 2, 3))                  #调用，序列解包
1 2 3
>>> demo(1, *(2, 3))                  #位置参数和序列解包同时使用
1 2 3
>>> demo(1, *(2,), 3)
1 2 3


'''

'''
变量起作用的代码范围称为变量的作用域，不同作用域内变量名可以相同，互不影响。
局部变量：在函数内部定义并使用的普通变量，只在函数内部起作用，称为局部变量，当函数执行结束后，局部变量自动删除，不再可以使用。
局部变量的引用比全局变量速度快，应优先考虑使用。

全局变量：与局部变量相对应，能够作用于函数内外的变量。
在函数体外定义的变量为全局变量；
在函数内，通过关键字global修饰的变量为全局变量，分两种情况：
一个变量已在函数外定义，如果在函数内需要为这个变量赋值，并要将这个赋值结果反映到函数外，可以在函数内使用global将其声明为全局变量。
如果一个变量在函数外没有定义，在函数内部也可以直接将一个变量定义为全局变量，该函数执行后，将增加一个新的全局变量。

注意：在某个作用域内任意位置只要有为变量赋值的操作，该变量在这个作用域内就是局部变量，除非使用global进行了声明。
>>> x = 3
>>> def f():
        print(x)           #本意是先输出全局变量x的值，但是不允许这样做
        x = 5              #有赋值操作，因此在整个作用域内x都是局部变量
        print(x)

>>> f()
Traceback (most recent call last):
  File "<pyshell#10>", line 1, in <module>
    f()
  File "<pyshell#9>", line 2, in f
    print(x)
UnboundLocalError: local variable 'x' referenced before assignment

如果局部变量与全局变量具有相同的名字，那么该局部变量会在自己的作用域内隐藏同名的全局变量


'''

'''
lambda表达式可以用来声明匿名函数，也就是没有函数名字的临时使用的小函数，尤其适合需要一个函数作为另一个函数参数的场合。也可以定义具名函数。
lambda表达式只可以包含一个表达式，该表达式的计算结果可以看作是函数的返回值，不允许包含复合语句，但在表达式中可以调用其他函数。
语法如下：
result = lambda [arg1 [, arg2, …, argn ] ] : expression
result: 用于调用lambda 表达式
[arg1 [, arg2, …, argn ] ]: 可选参数，指定要传递的参数列表
Expression: 指定实现的功能


'''
f = lambda x,y,z: x+y+z
print(f(1,2,3))

L = [(lambda x: x**2),(lambda x: x**3),(lambda x: x**4)]    # 列表元素是函数
print(L[0](2),L[1](2),L[2](2))  # 4 8 16
D = {'f1':(lambda:2+3), 'f2':(lambda:2*3), 'f3':(lambda:2**3)}  # 字典值是函数
print(D['f1'](), D['f2'](), D['f3']())


















































































