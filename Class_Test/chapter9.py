# coder:也
# 开发时间:2022/11/26 21:11

"""
文件内容操作
"""
'''
按文件中数据的组织形式把文件分为文本文件和二进制文件两类。
文本文件：文本文件存储的是常规字符串，由若干文本行组成，通常每行以换行符'\n'结尾。常规字符串是指记事本或其他文本编辑器能正常显示、编辑并且人类能够直接阅读和理解的字符串，如英文字母、汉字、数字字符串。文本文件可以使用字处理软件如gedit、记事本进行编辑。
二进制文件：二进制文件把对象内容以字节串(bytes)进行存储，无法用记事本或其他普通字处理软件直接进行编辑，通常也无法被人类直接阅读和理解，需要使用专门的软件进行解码后读取、显示、修改或执行。常见的如图形图像文件、音视频文件、可执行文件、资源文件、各种数据库文件、各类office文档等都属于二进制文件。

无论是文本文件还是二进制文件，其操作流程基本都是一致的，首先打开文件并创建文件对象，然后通过该文件对象对文件内容进行读取、写入、删除、修改等操作，最后关闭并保存文件内容。


'''
# 内置函数 open()
'''
open(file, mode='r', buffering=-1, encoding=None, errors=None,
     newline=None, closefd=True, opener=None)

file参数指定了被打开的文件名称。
mode参数指定了打开文件后的处理方式。
buffering参数指定了读写文件的缓存模式。0表示不缓存，1表示缓存，如大于1则表示缓冲区的大小。默认值是缓存模式。
encoding参数指定对文本进行编码和解码的方式，只适用于文本模式，可以使用Python支持的任何格式，如GBK、utf8、CP936等等。

模式	说明
r	读模式（默认模式，可省略），如果文件不存在则抛出异常
w	写模式，如果文件已存在，先清空原有内容
x	写模式，创建新文件，如果文件已存在则抛出异常
a	追加模式，不覆盖文件中原有内容
b	二进制模式（可与其他模式组合使用）
t	文本模式（默认模式，可省略）
+	读、写模式（可与其他模式组合使用）

如果执行正常，open()函数返回1个文件对象，通过该文件对象可以对文件进行读写操作。如果指定文件不存在、访问权限不够、磁盘空间不足或其他原因导致创建文件对象失败则抛出异常。

f1 = open( 'file1.txt', 'r' )     # 以读模式打开文件
f2 = open( 'file2.txt', 'w')      # 以写模式打开文件

当对文件内容操作完以后，一定要关闭文件对象，这样才能保证所做的任何修改都确实被保存到文件中。
f1.close()

方法	功能说明
close()	把缓冲区的内容写入文件，同时关闭文件，并释放文件对象
flush()	把缓冲区的内容写入文件，但不关闭文件
read([size])	从文本文件中读取size个字符（Python 3.x）的内容作为结果返回，或从二进制文件中读取指定数量的字节并返回，如果省略size则表示读取所有内容
readline()	从文本文件中读取一行内容作为结果返回
readlines()	把文本文件中的每行文本作为一个字符串存入列表中，返回该列表
seek(offset[, whence])	把文件指针移动到新的字节位置，offset表示相对于whence的位置。whence为0表示从文件头开始计算，1表示从当前位置开始计算，2表示从文件尾开始计算，默认为0
tell()		返回文件指针的当前位置
write(s)	把s的内容写入文件
writelines(s)	把字符串列表写入文本文件，不自动添加换行符

在实际开发中，读写文件应优先考虑使用上下文管理语句with，关键字with可以自动管理资源，不论因为什么原因（哪怕是代码引发了异常）跳出with块，总能保证文件被正确关闭，并且可以在代码块执行完毕后自动还原进入该代码块时的上下文，常用于文件操作、数据库连接、网络连接、多线程与多进程同步时的锁对象管理等场合。
with open(filename, mode, encoding) as fp:
    #这里写通过文件对象fp读写文件内容的语句

上下文管理语句with还支持下面的用法：
with open('test.txt', 'r') as src, open('test_new.txt', 'w') as dst:
	dst.write(src.read())







'''
s = 'Hello world\n文本文件的读取方法\n文本文件的写入方法\n'
with open('123.txt','w') as fp:
    fp.write(s)
with open('123.txt') as fp:
    print(fp.read())

'''
>>> import json
>>> json.dumps(['a','b','c'])             # 序列化列表对象
'["a", "b", "c"]'
>>> json.loads(_)                         # 反序列化，还原对象
['a', 'b', 'c']
>>> json.dumps({'a':1, 'b':2, 'c':3})     # 序列化字典对象
'{"a": 1, "b": 2, "c": 3}'
>>> json.loads(_)
{'a': 1, 'b': 2, 'c': 3}
>>> json.dumps([1,2,3,{'4': 5, '6': 7}])
'[1, 2, 3, {"4": 5, "6": 7}]'
# 指定分隔符，可以压缩存储，注意和上面结果的区别
>>> json.dumps([1,2,3,{'4':5, '6':7}], separators=(',', ':'))
'[1,2,3,{"4":5,"6":7}]'
>>> json.loads(_)
[1, 2, 3, {'4': 5, '6': 7}]
>>> json.dumps('山东烟台')                 # 序列化中文字符串
'"\\u5c71\\u4e1c\\u70df\\u53f0"'
>>> json.loads(_)
'山东烟台'


数据库文件、图像文件、可执行文件、动态链接库文件、音频文件、视频文件、Office文档等均属于二进制文件。
对于二进制文件，不能使用记事本或其他文本编辑软件直接进行正常读写，也不能通过Python的文件对象直接读取和理解二进制文件的内容。必须正确理解二进制文件结构和序列化规则，然后设计正确的反序列化规则，才能准确地理解二进制文件内容。
所谓序列化，简单地说就是把内存中的数据在不丢失其类型信息的情况下转成二进制形式的过程，对象序列化后的数据经过正确的反序列化过程应该能够准确无误地恢复为原来的对象。
Python中常用的序列化模块有struct、pickle、shelve、marshal。

例9-12   使用pickle模块写入二进制文件。
import pickle

i = 13000000
a = 99.056
s = '中国人民 123abc'
lst = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
tu = (-5, 10, 8)
coll = {4, 5, 6}
dic = {'a':'apple', 'b':'banana', 'g':'grape', 'o':'orange'}
data = (i, a, s, lst, tu, coll, dic)
with open('sample_pickle.dat', 'wb') as f:
    try:
        pickle.dump(len(data), f)        #要序列化的对象个数
        for item in data:
            pickle.dump(item, f)         #序列化数据并写入文件
    except:
        print('写文件异常')

Python标准库shelve也提供了二进制文件操作的功能，可以像字典赋值一样来写入二进制文件，也可以像字典一样读取二进制文件。

>>> import shelve
>>> zhangsan = {'age':38, 'sex':'Male', 'address':'SDIBT'}
>>> lisi = {'age':40, 'sex':'Male', 'qq':'1234567', 'tel':'7654321'}
>>> with shelve.open('shelve_test.dat') as fp:
    fp['zhangsan'] = zhangsan      # 像操作字典一样把数据写入文件
    fp['lisi'] = lisi
    for i in range(5):
        fp[str(i)] = str(i)



'''






















































































